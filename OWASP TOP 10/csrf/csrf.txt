Cross-Site Request Forgery (CSRF) is an attack that tricks a user into performing actions on a web application in which they are authenticated, without their consent. It exploits the trust that a web application has in the user's browser.

How CSRF Works
Victim Authentication: The victim logs into a web application (e.g., a banking site) and the session cookie is stored in their browser.
Malicious Request: The attacker crafts a malicious request (e.g., a request to transfer money) and sends it to the victim (via email, social media, etc.).
Request Execution: If the victim's browser sends this request to the web application while still authenticated, the application executes the request as if it were made by the victim.
Example Scenario
Consider a banking application that allows users to transfer funds using a simple form:

html
Copy code
<form action="https://bank.com/transfer" method="POST">
  <input type="hidden" name="account" value="12345">
  <input type="hidden" name="amount" value="1000">
  <input type="submit" value="Transfer">
</form>
An attacker might create a malicious webpage containing the same form but pre-filled with the attacker's account details:

html
Copy code
<html>
  <body>
    <h1>Click this button to win a prize!</h1>
    <form action="https://bank.com/transfer" method="POST">
      <input type="hidden" name="account" value="attacker-account">
      <input type="hidden" name="amount" value="1000">
      <input type="submit" value="Claim your prize">
    </form>
  </body>
</html>
When the victim, already logged into their bank account, clicks the submit button on the attacker's page, their browser sends the request to https://bank.com/transfer with the victim's session cookie. The bank processes the transfer, moving money from the victim's account to the attacker's account.

Preventing CSRF
CSRF Tokens: Include a unique token in forms that is validated on the server side. This token is tied to the user's session and must be submitted with the request.

html
Copy code
<form action="https://bank.com/transfer" method="POST">
  <input type="hidden" name="csrf_token" value="random-generated-token">
  <input type="hidden" name="account" value="12345">
  <input type="hidden" name="amount" value="1000">
  <input type="submit" value="Transfer">
</form>
On the server side, validate the csrf_token to ensure it matches the one generated for the user's session.

SameSite Cookies: Use the SameSite attribute in cookies to restrict when cookies are sent with requests. Setting SameSite=Lax or SameSite=Strict can mitigate CSRF by not sending cookies on cross-origin requests.

http
Copy code
Set-Cookie: sessionid=abcd1234; SameSite=Lax
Double Submit Cookies: Send a CSRF token in both a cookie and a request parameter, and verify that they match on the server.

Referer Header Validation: Check the Referer header to ensure the request comes from an expected origin. However, this can be bypassed in some cases and is not as robust as token-based methods.

By implementing these measures, web applications can significantly reduce the risk of CSRF attacks.